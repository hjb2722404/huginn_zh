#!/usr/bin/env ruby

require 'cgi'
require 'httparty'
require 'date'

module Agents
  class JiraAgent < Agent
    include WebRequestConcern

    cannot_receive_events!

    description <<-MD

      Jira Agent订阅了Jira问题更新

      JIRA 是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件

      - `jira_url` 指定jira安装的完整URL，包括https：//
      - `jql` 是一个可选的基于Jira查询语言的过滤器，用于限制事件流。 有关详细信息，请参阅[JQL文档 JQL Docs](https://confluence.atlassian.com/display/JIRA/Advanced+Searching) 。 
      - `username` 和 `password` 是可选的，如果您的Jira实例受到读保护，则可能需要指定
      - `timeout`  是一个可选参数，指定请求处理在几分钟内可能需要多长时间。

      代理执行定期查询并以JSON格式发出包含更新问题的事件。

      注意：首次执行时，代理将获取JQL查询可用的所有内容。 因此，如果不可取，​​请按日期限制jql查询。
    MD

    event_description <<-MD
      Events are the raw JSON generated by Jira REST API

      {
        "expand": "editmeta,renderedFields,transitions,changelog,operations",
        "id": "80127",
        "self": "https://jira.atlassian.com/rest/api/2/issue/80127",
        "key": "BAM-3512",
        "fields": {
          ...
        }
      }
    MD

    default_schedule "every_10m"
    MAX_EMPTY_REQUESTS = 10

    def default_options
      {
        'username'  => '',
        'password' => '',
        'jira_url' => 'https://jira.atlassian.com',
        'jql' => '',
        'expected_update_period_in_days' => '7',
        'timeout' => '1'
      }
    end

    def validate_options
      errors.add(:base, "you need to specify password if user name is set") if options['username'].present? and not options['password'].present?
      errors.add(:base, "you need to specify your jira URL") unless options['jira_url'].present?
      errors.add(:base, "you need to specify the expected update period") unless options['expected_update_period_in_days'].present?
      errors.add(:base, "you need to specify request timeout") unless options['timeout'].present?
    end

    def working?
      event_created_within?(interpolated['expected_update_period_in_days']) && !recent_error_logs?
    end

    def check
      last_run = nil

      current_run = Time.now.utc.iso8601
      last_run = Time.parse(memory[:last_run]) if memory[:last_run]
      issues = get_issues(last_run)

      issues.each do |issue|
        updated = Time.parse(issue['fields']['updated'])

        # this check is more precise than in get_issues()
        # see get_issues() for explanation
        if not last_run or updated > last_run
          create_event :payload => issue
        end
      end

      memory[:last_run] = current_run
    end

  private
    def request_url(jql, start_at)
      "#{interpolated[:jira_url]}/rest/api/2/search?jql=#{CGI::escape(jql)}&fields=*all&startAt=#{start_at}"
    end

    def request_options
      ropts = { headers: {"User-Agent" => user_agent} }

      if !interpolated[:username].empty?
        ropts = ropts.merge({:basic_auth => {:username =>interpolated[:username], :password=>interpolated[:password]}})
      end

      ropts
    end

    def get(url, options)
        response = HTTParty.get(url, options)

        if response.code == 400
          raise RuntimeError.new("Jira error: #{response['errorMessages']}") 
        elsif response.code == 403
          raise RuntimeError.new("Authentication failed: Forbidden (403)")
        elsif response.code != 200
          raise RuntimeError.new("Request failed: #{response}")
        end

        response
    end

    def get_issues(since)
      startAt = 0
      issues = []

      # JQL doesn't have an ability to specify timezones
      # Because of this we have to fetch issues 24 h
      # earlier and filter out unnecessary ones at a later
      # stage. Fortunately, the 'updated' field has GMT
      # offset
      since -= 24*60*60 if since

      jql = ""

      if !interpolated[:jql].empty? && since
        jql = "(#{interpolated[:jql]}) and updated >= '#{since.strftime('%Y-%m-%d %H:%M')}'"
      else
        jql = interpolated[:jql] if !interpolated[:jql].empty?
        jql = "updated >= '#{since.strftime('%Y-%m-%d %H:%M')}'" if since
      end

      start_time = Time.now

      request_limit = 0
      loop do
        response = get(request_url(jql, startAt), request_options)

        if response['issues'].length == 0
          request_limit+=1
        end

        if request_limit > MAX_EMPTY_REQUESTS
          raise RuntimeError.new("There is no progress while fetching issues")
        end

        if Time.now > start_time + interpolated['timeout'].to_i * 60
          raise RuntimeError.new("Timeout exceeded while fetching issues")
        end

        issues += response['issues']
        startAt += response['issues'].length
 
        break if startAt >= response['total']
      end

      issues
    end

  end
end

